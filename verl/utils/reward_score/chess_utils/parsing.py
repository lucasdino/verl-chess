import re
import ast
from typing import Dict



class ParseException(Exception):
    """ Exception raised when model generates an output that cannot be parsed. """
    pass

# =================================================
# General Functionality
# =================================================
def extract_solution(text: str) -> str:
    """ Extracts text between <answer> and </answer> tags, trims it, and returns it. """
    matches = re.findall(r"<answer>(.*?)</answer>", text, re.DOTALL)
    if not matches:
        raise ParseException("No valid pair of <answer> tags found.")
    extracted = matches[-1].strip()
    return extracted


def coerce_response(text: str, task_type: str, **kwargs) -> str:
    """ Given an output generated by an LLM, coerces it to be in a more workable format. """
    try:
        processed_text = ast.literal_eval(text)
    except:
        processed_text = text

    # Need output to be a single string (no list)
    if task_type == 'choose_from_n' or task_type == 'predict_singlemove' or task_type == 'predict_in_list':
        if isinstance(processed_text, str):
            processed_text = _stringify_move(processed_text)
        elif isinstance(processed_text, list):
            if len(processed_text) == 1:
                processed_text = _stringify_move(processed_text[0])
            elif len(processed_text) > 1:
                raise ParseException("Output is a list with multiple elements.")
        else:
            raise ParseException("Output is not in the correct format.") 
    
    # Need to coerce to a list of strings
    elif task_type == 'produce_list':
        if isinstance(processed_text, list):
            # Process each element to ensure all elements are strings
            processed_text = [_stringify_move(x) for x in processed_text]
        elif isinstance(processed_text, str):
            processed_text = re.split(r'[\s,]+', processed_text.strip()) if processed_text.strip() else []
            processed_text = _coerce_string_list(processed_text)
        else:
            raise ParseException("Output is not a list.")
    
    # Need to coerce a list of tuples (position / move, piece)
    elif task_type == "hallucination":
        pass

    # Need to coerce list into a dict of key: bool
    elif task_type == "reasoning_strategy":
        extracted = extract_solution(text)
        return _coerce_dict_bool(extracted)

    else:
        raise ValueError(f"Unknown eval type: {task_type}")
    
    return processed_text


def pqt_extract_ground_truth(answer, task_type):
    if task_type == "predict_singlemove":
        return ast.literal_eval(answer)
    elif task_type == "choose_from_n":
        return ast.literal_eval(answer)
    elif task_type == "produce_list":
        return ast.literal_eval(answer)
    else:
        raise ValueError(f"Task type: {task_type} is undefined.")


# ==================================================
# Helper Functions
# ==================================================
def _stringify_move(move: str) -> str:
    return ''.join(c for c in move if c.isalnum())    

def _coerce_string_list(items: list[str]) -> list[str]:
    pattern = re.compile(r'^[a-zA-Z]\d(?:[a-zA-Z]\d)?$')
    filtered = [item for item in items if pattern.match(item)]
    
    if not filtered:
        raise ParseException("No valid items found in input.")
    
    return filtered

def _coerce_dict_bool(items: str) -> Dict[str, int]:
    """
    Parse a dict-like string of reasoning-strategy flags and return
    {key: 0|1}.  Accepts 0/1, True/False, "0"/"1", "true"/"false",
    and also tuples like (True, "explanation").  Collects all problems
    before raising ParseException.
    """
    allowed_keys = {
        "Enumeration",
        "Tree Search",
        "Backtracking",
        "Self Correction",
        "Subgoal Setting",
        "Verification",
    }

    # --- literal-eval --------------------------------------------------------
    try:
        parsed = ast.literal_eval(items)
    except Exception as e:
        raise ParseException(f"Failed to parse input as a dictionary: {e}")

    if not isinstance(parsed, dict):
        raise ParseException("Parsed input is not a dictionary.")

    # --- validate & coerce ---------------------------------------------------
    errors, result = [], {}

    for key, value in parsed.items():
        # key check
        if key not in allowed_keys:
            errors.append(f"Invalid key: '{key}' (allowed: {sorted(allowed_keys)})")
            continue  # still inspect value to collect all errors

        # look only at first element if tuple / list
        v = value[0] if isinstance(value, (tuple, list)) else value

        # map to 0 / 1
        if isinstance(v, str):
            v = v.strip().lower()
            norm = 1 if v in {"1", "true"} else 0 if v in {"0", "false"} else None
        elif isinstance(v, (bool, int)):
            norm = 1 if v in {1, True} else 0 if v in {0, False} else None
        else:
            norm = None

        if norm is None:
            errors.append(
                f"Invalid value for key '{key}': {value!r} "
                "(must be 0/1, '0'/'1', True/False)"
            )
        else:
            result[key] = norm

    if errors:
        raise ParseException("Errors in input:\n" + "\n".join(errors))

    return result

